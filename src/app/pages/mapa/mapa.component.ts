import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { AfterViewInit, Component, OnDestroy, OnInit } from '@angular/core';
import { FormsModule } from '@angular/forms';
import {
  Icon,
  Map as LeafletMap,
  Marker,
  Polyline,
  divIcon,
  latLngBounds,
  marker,
  polyline,
  tileLayer,
} from 'leaflet';
import { Subscription, firstValueFrom } from 'rxjs';
import {
  PuntoReciclaje,
  PuntosReciclajeService,
} from '../../Services/puntos-reciclaje.service';

interface OsrmStep {
  name: string;
  maneuver: {
    type: string;
    modifier?: string;
    location?: [number, number];
    bearing_after?: number;
  };
}

interface OsrmRoute {
  distance: number;
  duration: number;
  geometry: {
    coordinates: [number, number][];
  };
  legs: Array<{
    steps: OsrmStep[];
  }>;
}

interface OsrmResponse {
  routes: OsrmRoute[];
}

interface RutaPaso {
  texto: string;
  lat: number;
  lng: number;
  angulo?: number;
}

interface RutaCalculada {
  etiqueta: string;
  distanciaKm: number;
  duracionMin: number;
  pasos: RutaPaso[];
  geometria: [number, number][];
}

@Component({
  selector: 'app-mapa',
  standalone: true,
  templateUrl: './mapa.component.html',
  styleUrls: ['./mapa.component.css'],
  imports: [CommonModule, FormsModule],
})
export class MapaComponent implements AfterViewInit, OnDestroy, OnInit {
  private static instanceCounter = 0;
  private readonly bogotaCoords: [number, number] = [4.711, -74.0721];
  private readonly defaultZoom = 13;
  private mapInstance?: LeafletMap;
  private dataMarkers: Marker[] = [];
  private markerIndex = new Map<number, Marker>();
  private routeLine?: Polyline;
  private origenMarker?: Marker;
  private cursorMarker?: Marker;
  private origenCoords?: { lat: number; lng: number };
  private puntosSub?: Subscription;
  private refreshSub?: Subscription;
  private colorRutaActual = '#2563eb';

  public readonly mapContainerId = `mapa-bogota-${++MapaComponent.instanceCounter}`;
  public puntos: PuntoReciclaje[] = [];
  public puntosDecorados: Array<PuntoReciclaje & { cardColor: string; borderColor: string; chipBg: string; chipColor: string }> = [];
  public origenInput = '';
  public destinoSeleccionadoId: number | null = null;
  public rutasCalculadas: RutaCalculada[] = [];
  public rutaSeleccionadaIndex = 0;
  public mostrarPasosOverlay = false;
  public pasosVisibles: RutaPaso[] = [];
  public rutaCalculando = false;
  public rutaError = '';

  constructor(
    private readonly puntosService: PuntosReciclajeService,
    private readonly http: HttpClient
  ) {}

  ngOnInit(): void {
    this.refreshSub = this.puntosService.refresh$.subscribe(() => this.cargarPuntos());
  }

  ngAfterViewInit(): void {
    this.mapInstance = new LeafletMap(this.mapContainerId, {
      center: this.bogotaCoords,
      zoom: this.defaultZoom,
      zoomControl: false,
    });

    tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19,
    }).addTo(this.mapInstance);

    this.cargarPuntos();
  }

  ngOnDestroy(): void {
    this.puntosSub?.unsubscribe();
    this.refreshSub?.unsubscribe();
    this.routeLine?.remove();
    this.origenMarker?.remove();
    this.cursorMarker?.remove();
    this.limpiarMarcadores();
    this.mapInstance?.remove();
  }

  private cargarPuntos(): void {
    this.puntosSub?.unsubscribe();
    this.puntosSub = this.puntosService.getPuntos().subscribe({
      next: (response) => {
        const puntos = response?.data ?? [];
        this.puntos = puntos;
        this.puntosDecorados = puntos.map((punto) => ({
          ...punto,
          ...this.obtenerColoresTarjeta(punto.tipoResiduo ?? ''),
        }));
        this.limpiarMarcadores();
        puntos.forEach((punto) => this.crearMarcador(punto));
        this.ajustarVistaMapa();
      },
      error: (err) => {
        console.error('Error al obtener los puntos de reciclaje', err);
      },
    });
  }

  private crearMarcador(punto: PuntoReciclaje): void {
    if (!this.mapInstance) {
      return;
    }

    const lat = Number(punto.latitud);
    const lng = Number(punto.longitud);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return;
    }

    const nuevoMarcador = marker([lat, lng], {
      icon: this.getIconoResiduo(punto.tipoResiduo ?? ''),
    })
      .addTo(this.mapInstance)
      .bindPopup(this.obtenerPopupContenido(punto));

    this.dataMarkers.push(nuevoMarcador);
    if (punto.id !== undefined) {
      this.markerIndex.set(punto.id, nuevoMarcador);
    }
  }

  private obtenerPopupContenido(punto: PuntoReciclaje): string {
    const nombre = punto.nombre ?? 'Punto sin nombre';
    const direccion = punto.direccion ?? 'Direcci贸n no disponible';
    const horario = punto.horario ?? 'Horario no informado';
    const tipoResiduo = punto.tipoResiduo ?? 'Tipo no especificado';
    const descripcion = punto.descripcion ?? '';

    return `
      <div class="popup-punto">
        <strong>${nombre}</strong><br>
        <small>${direccion}</small>
        <hr>
        <div><strong>Horario:</strong> ${horario}</div>
        <div><strong>Residuo:</strong> ${tipoResiduo}</div>
        ${descripcion ? `<div><strong>Descripci贸n:</strong> ${descripcion}</div>` : ''}
      </div>
    `;
  }

  private limpiarMarcadores(): void {
    this.dataMarkers.forEach((mk) => mk.remove());
    this.dataMarkers = [];
    this.markerIndex.clear();
  }

  private ajustarVistaMapa(): void {
    if (!this.mapInstance) {
      return;
    }

    if (!this.dataMarkers.length) {
      this.mapInstance.setView(this.bogotaCoords, this.defaultZoom);
      return;
    }

    const bounds = latLngBounds(this.dataMarkers.map((mk) => mk.getLatLng()));
    this.mapInstance.fitBounds(bounds, { padding: [24, 24] });
  }

  public usarMiUbicacion(): void {
    if (!navigator.geolocation) {
      this.rutaError = 'Tu navegador no soporta geolocalizaci贸n.';
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const { latitude, longitude } = position.coords;
        this.origenCoords = { lat: latitude, lng: longitude };
        this.rutaError = '';
        this.mapInstance?.setView([latitude, longitude], 15);
        await this.actualizarDireccionDesdeCoordenadas(latitude, longitude);
      },
      (error) => {
        console.error('Error geolocalizaci贸n', error);
        this.rutaError = 'No pudimos obtener tu ubicaci贸n.';
      }
    );
  }

  public async calcularRuta(): Promise<void> {
    this.rutaError = '';
    this.rutasCalculadas = [];
    this.mostrarPasosOverlay = false;
    this.pasosVisibles = [];
    this.routeLine?.remove();

    let origen: { lat: number; lng: number };
    try {
      origen = await this.obtenerCoordenadasOrigen();
    } catch (error) {
      this.rutaError =
        error instanceof Error
          ? error.message
          : 'No pudimos interpretar el origen indicado.';
      return;
    }

    const destino = this.puntos.find((p) => p.id === this.destinoSeleccionadoId);
    if (!destino) {
      this.rutaError = 'Selecciona un punto de destino.';
      return;
    }

    const destLat = Number(destino.latitud);
    const destLng = Number(destino.longitud);
    if (Number.isNaN(destLat) || Number.isNaN(destLng)) {
      this.rutaError = 'El destino no tiene coordenadas v谩lidas.';
      return;
    }

    this.colorRutaActual = this.obtenerColorResiduo(destino.tipoResiduo ?? '');
    this.marcarOrigen(origen);

    const url = `https://router.project-osrm.org/route/v1/driving/${origen.lng},${origen.lat};${destLng},${destLat}?overview=full&geometries=geojson&steps=true&alternatives=2`;
    this.rutaCalculando = true;

    this.http.get<OsrmResponse>(url).subscribe({
      next: (response) => {
        this.rutaCalculando = false;
        const routes = response?.routes ?? [];
        if (!routes.length) {
          this.rutaError = 'No encontramos rutas disponibles.';
          return;
        }

        this.rutasCalculadas = routes.slice(0, 2).map((route, index) => ({
          etiqueta: index === 0 ? 'Ruta recomendada' : 'Opci贸n alternativa',
          distanciaKm: +(route.distance / 1000).toFixed(2),
          duracionMin: +(route.duration / 60).toFixed(1),
          pasos: this.extraerInstrucciones(route.legs?.[0]?.steps ?? []),
          geometria: route.geometry.coordinates,
        }));

        this.seleccionarRuta(0);
      },
      error: (err) => {
        console.error('Error OSRM', err);
        this.rutaCalculando = false;
        this.rutaError = 'No se pudo calcular la ruta con OSRM.';
      },
    });
  }

  public seleccionarRuta(index: number): void {
    const ruta = this.rutasCalculadas[index];
    if (!ruta) {
      return;
    }

    this.rutaSeleccionadaIndex = index;
    this.pasosVisibles = ruta.pasos;
    this.mostrarPasosOverlay = true;
    this.dibujarRuta(ruta.geometria);
  }

  public centrarEnPunto(punto: PuntoReciclaje): void {
    if (!this.mapInstance) {
      return;
    }

    const lat = Number(punto.latitud);
    const lng = Number(punto.longitud);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return;
    }

    this.mapInstance.setView([lat, lng], 16, { animate: true } as any);
    if (punto.id !== undefined) {
      const markerRef = this.markerIndex.get(punto.id);
      markerRef?.openPopup();
    }
  }

  private async obtenerCoordenadasOrigen(): Promise<{ lat: number; lng: number }> {
    const valor = this.origenInput.trim();

    if (valor) {
      const coords = this.parseLatLngString(valor);
      if (coords) {
        this.origenCoords = coords;
        return coords;
      }

      return this.geocodificarDireccion(valor);
    }

    if (this.origenCoords) {
      return this.origenCoords;
    }

    throw new Error('Ingresa una direcci贸n de origen o utiliza tu ubicaci贸n actual.');
  }

  private parseLatLngString(value: string): { lat: number; lng: number } | null {
    const parts = value.split(',').map((part) => Number(part.trim()));
    if (parts.length !== 2) {
      return null;
    }

    const [lat, lng] = parts;
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return null;
    }

    return { lat, lng };
  }

  private dibujarRuta(coordinates: [number, number][]): void {
    if (!this.mapInstance || !coordinates.length) {
      return;
    }

    const latLngCoords = coordinates.map(([lng, lat]) => [lat, lng] as [number, number]);
    this.routeLine?.remove();
    this.cursorMarker?.remove();
    this.routeLine = polyline(latLngCoords, {
      color: this.colorRutaActual,
      weight: 6,
      opacity: 0.85,
      lineJoin: 'round',
    }).addTo(this.mapInstance);

    this.mapInstance.fitBounds(this.routeLine.getBounds(), { padding: [36, 36] });
    this.colocarCursorDireccion(latLngCoords);
  }

  private colocarCursorDireccion(coords: [number, number][]): void {
    if (!this.mapInstance || coords.length < 2) {
      return;
    }

    this.cursorMarker?.remove();
    const [inicioLat, inicioLng] = coords[0];
    const [sigLat, sigLng] = coords[1];
    const angulo = Math.atan2(sigLat - inicioLat, sigLng - inicioLng) * (180 / Math.PI);

    this.cursorMarker = marker([inicioLat, inicioLng], {
      icon: divIcon({
        className: 'route-cursor-wrapper',
        html: `<div class="route-cursor" style="--cursor-angle: ${angulo}deg"></div>`,
        iconSize: [40, 40],
        iconAnchor: [20, 20],
      }),
      interactive: false,
    }).addTo(this.mapInstance);
  }

  private marcarOrigen(coords: { lat: number; lng: number }): void {
    if (!this.mapInstance) {
      return;
    }

    this.origenMarker?.remove();
    this.origenMarker = marker([coords.lat, coords.lng], {
      icon: divIcon({
        className: 'origin-dot-wrapper',
        html: '<div class="origin-dot"></div>',
        iconSize: [32, 32],
        iconAnchor: [16, 16],
      }),
    }).addTo(this.mapInstance);
  }

  private extraerInstrucciones(steps: OsrmStep[]): RutaPaso[] {
    if (!steps.length) {
      const lat = this.origenCoords?.lat ?? this.bogotaCoords[0];
      const lng = this.origenCoords?.lng ?? this.bogotaCoords[1];
      return [{ texto: 'Sigue la v铆a principal hasta tu destino.', lat, lng }];
    }

    return steps.map((step, index) => {
      const accion = this.obtenerTextoPaso(step.maneuver.type, step.maneuver.modifier);
      const via = step.name ? ` hacia ${step.name}` : '';
      const location = step.maneuver.location;
      const lat = location ? location[1] : this.bogotaCoords[0];
      const lng = location ? location[0] : this.bogotaCoords[1];
      const bearing = step.maneuver.bearing_after;
      const angulo = typeof bearing === 'number'
        ? bearing - 90
        : this.obtenerAnguloPorModifier(step.maneuver.modifier);
      return { texto: `${accion}${via}`.trim(), lat, lng, angulo };
    });
  }

  private obtenerTextoPaso(type: string, modifier?: string): string {
    switch (type) {
      case 'depart':
        return 'Inicia el recorrido';
      case 'arrive':
        return 'Has llegado al destino';
      case 'turn':
      case 'continue':
      case 'new name':
      case 'merge':
      case 'exit':
        return this.traducirGiro(modifier);
      case 'roundabout':
        return 'Ingresa a la rotonda';
      default:
        return 'Contin煤a recto';
    }
  }

  private traducirGiro(modifier?: string): string {
    const map: Record<string, string> = {
      left: 'Gira a la izquierda',
      right: 'Gira a la derecha',
      straight: 'Contin煤a recto',
      slight_left: 'Gira levemente a la izquierda',
      slight_right: 'Gira levemente a la derecha',
      sharp_left: 'Gira pronunciadamente a la izquierda',
      sharp_right: 'Gira pronunciadamente a la derecha',
      uturn: 'Realiza un giro en U',
    };

    if (!modifier) {
      return 'Contin煤a recto';
    }

    return map[modifier] ?? 'Contin煤a recto';
  }

  private async geocodificarDireccion(termino: string): Promise<{ lat: number; lng: number }> {
    const url = 'https://nominatim.openstreetmap.org/search';
    try {
      const respuesta = await firstValueFrom(
        this.http.get<Array<{ lat: string; lon: string }>>(url, {
          params: {
            format: 'json',
            addressdetails: '0',
            limit: '1',
            q: termino,
          },
          headers: {
            'Accept-Language': 'es',
          },
        })
      );

      const coincidencia = respuesta?.[0];
      if (!coincidencia) {
        throw new Error('No encontramos la direcci贸n especificada.');
      }

      const lat = Number(coincidencia.lat);
      const lng = Number(coincidencia.lon);
      if (Number.isNaN(lat) || Number.isNaN(lng)) {
        throw new Error('No pudimos interpretar la direcci贸n proporcionada.');
      }

      this.origenCoords = { lat, lng };
      return { lat, lng };
    } catch (error) {
      console.error('Error geocodificando direcci贸n', error);
      throw new Error('No pudimos convertir la direcci贸n a coordenadas.');
    }
  }

  private async actualizarDireccionDesdeCoordenadas(lat: number, lng: number): Promise<void> {
    const url = 'https://nominatim.openstreetmap.org/reverse';
    try {
      const respuesta = await firstValueFrom(
        this.http.get<{ display_name?: string }>(url, {
          params: {
            format: 'json',
            lat: lat.toString(),
            lon: lng.toString(),
          },
          headers: {
            'Accept-Language': 'es',
          },
        })
      );

      this.origenInput = respuesta?.display_name ?? `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    } catch (error) {
      console.error('Error al obtener la direcci贸n desde coordenadas', error);
      this.origenInput = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    }
  }

  private getIconoResiduo(tipo: string): Icon {
    const normalized = (tipo || '').toLowerCase();
    const iconMap: Record<string, string> = {
      papel: 'assets/papel.png',
      vidrio: 'assets/vidrio.png',
      plastico: 'assets/plastico.png',
      pl谩stico: 'assets/plastico.png',
      metal: 'assets/metal.png',
    };

    let iconPath = 'assets/default.png';
    if (normalized.includes('papel')) iconPath = iconMap['papel'];
    else if (normalized.includes('vidrio')) iconPath = iconMap['vidrio'];
    else if (normalized.includes('plastico') || normalized.includes('pl谩stico')) iconPath = iconMap['plastico'];
    else if (normalized.includes('metal') || normalized.includes('met谩lico')) iconPath = iconMap['metal'];

    return new Icon({
      iconUrl: iconPath,
      iconSize: [36, 36],
      iconAnchor: [18, 36],
      popupAnchor: [0, -32],
    });
  }

  private obtenerColorResiduo(tipo: string): string {
    const normalized = (tipo || '').toLowerCase();
    if (normalized.includes('papel')) return '#2563eb';
    if (normalized.includes('plastico') || normalized.includes('pl谩stico')) return '#fff200';
    if (normalized.includes('metal') || normalized.includes('met谩lico')) return '#dc2626';
    if (normalized.includes('vidrio')) return '#0f9d58';
    return '#0ea5e9';
  }

  private obtenerColoresTarjeta(tipo: string): {
    cardColor: string;
    borderColor: string;
    chipBg: string;
    chipColor: string;
  } {
    const normalized = (tipo || '').toLowerCase();
    if (normalized.includes('papel')) {
      return {
        cardColor: 'rgba(59, 130, 246, 0.12)',
        borderColor: 'rgba(30, 64, 175, 0.55)',
        chipBg: 'rgba(59, 130, 246, 0.25)',
        chipColor: '#1d4ed8',
      };
    }
    if (normalized.includes('plastico') || normalized.includes('pl谩stico')) {
      return {
        cardColor: 'rgba(250, 204, 21, 0.22)',
        borderColor: 'rgba(202, 138, 4, 0.65)',
        chipBg: 'rgba(250, 204, 21, 0.35)',
        chipColor: '#a16207',
      };
    }
    if (normalized.includes('metal') || normalized.includes('met谩lico')) {
      return {
        cardColor: 'rgba(220, 38, 38, 0.12)',
        borderColor: 'rgba(153, 27, 27, 0.55)',
        chipBg: 'rgba(248, 113, 113, 0.25)',
        chipColor: '#991b1b',
      };
    }
    if (normalized.includes('vidrio')) {
      return {
        cardColor: 'rgba(34, 197, 94, 0.18)',
        borderColor: 'rgba(22, 101, 52, 0.6)',
        chipBg: 'rgba(74, 222, 128, 0.25)',
        chipColor: '#166534',
      };
    }

    return {
      cardColor: 'rgba(15, 118, 110, 0.12)',
      borderColor: 'rgba(15, 118, 110, 0.5)',
      chipBg: 'rgba(20, 184, 166, 0.28)',
      chipColor: '#0f766e',
    };
  }

  public irAPaso(paso: RutaPaso): void {
    if (!this.mapInstance) {
      return;
    }

    this.mapInstance.setView([paso.lat, paso.lng], 17, { animate: true } as any);
    this.cursorMarker?.remove();
    this.cursorMarker = marker([paso.lat, paso.lng], {
      icon: divIcon({
        className: 'route-cursor-wrapper',
        html: `<div class="route-cursor route-cursor--active" style="--cursor-angle: ${(paso.angulo ?? 0)}deg"></div>`,
        iconSize: [40, 40],
        iconAnchor: [20, 20],
      }),
      interactive: false,
    }).addTo(this.mapInstance);
  }

  private obtenerAnguloPorModifier(modifier?: string): number {
    switch (modifier) {
      case 'right':
        return 90;
      case 'left':
        return -90;
      case 'straight':
        return 0;
      case 'uturn':
        return 180;
      case 'slight_right':
        return 45;
      case 'slight_left':
        return -45;
      case 'sharp_right':
        return 135;
      case 'sharp_left':
        return -135;
      default:
        return 0;
    }
  }
}
